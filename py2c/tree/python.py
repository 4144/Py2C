#------------------------------------------------------------------------------
# Py2C - A Python to C++ compiler
# Copyright (C) 2014 Pradyun S. Gedam
#------------------------------------------------------------------------------

# This file is auto-generated by py2c.tree.node_gen .
#------------------------------------------------------------------------------
# ANY CHANGES YOU MAKE IN THIS FILE DIRECTLY WILL BE LOST.
#------------------------------------------------------------------------------
# Instead of modifying this file, modify the relevant "*.tree" file
# in py2c/tree directory of the source distribution.

from . import (
    Node,
    identifier, singleton,
    NEEDED, OPTIONAL, ONE_OR_MORE, ZERO_OR_MORE
)


class PyAST(Node):
    _fields = []


class mod(PyAST):
    _fields = []


class stmt(PyAST):
    _fields = []


class expr(PyAST):
    _fields = []


class expr_context(PyAST):
    _fields = []


class slice(PyAST):
    _fields = []


class boolop(PyAST):
    _fields = []


class operator(PyAST):
    _fields = []


class unaryop(PyAST):
    _fields = []


class cmpop(PyAST):
    _fields = []


class arg(PyAST):
    _fields = [
        ('arg', identifier, NEEDED),
        ('annotation', expr, OPTIONAL),
    ]


class comprehension(PyAST):
    _fields = [
        ('target', expr, NEEDED),
        ('iter', expr, NEEDED),
        ('ifs', expr, ZERO_OR_MORE),
    ]


class arguments(PyAST):
    _fields = [
        ('args', arg, ZERO_OR_MORE),
        ('vararg', identifier, OPTIONAL),
        ('varargannotation', expr, OPTIONAL),
        ('kwonlyargs', arg, ZERO_OR_MORE),
        ('kwarg', identifier, OPTIONAL),
        ('kwargannotation', expr, OPTIONAL),
        ('defaults', expr, ZERO_OR_MORE),
        ('kw_defaults', expr, ZERO_OR_MORE),
    ]


class keyword(PyAST):
    _fields = [
        ('arg', identifier, NEEDED),
        ('value', expr, NEEDED),
    ]


class alias(PyAST):
    _fields = [
        ('name', str, NEEDED),
        ('asname', identifier, OPTIONAL),
    ]


class withitem(PyAST):
    _fields = [
        ('context_expr', expr, NEEDED),
        ('optional_vars', expr, OPTIONAL),
    ]


class ExceptHandler(PyAST):
    _fields = [
        ('type', expr, OPTIONAL),
        ('name', identifier, OPTIONAL),
        ('body', stmt, ZERO_OR_MORE),
    ]


class Module(mod):
    _fields = [
        ('body', stmt, ZERO_OR_MORE),
    ]


class FunctionDef(stmt):
    _fields = [
        ('name', identifier, NEEDED),
        ('args', arguments, NEEDED),
        ('body', stmt, ZERO_OR_MORE),
        ('decorator_list', expr, ZERO_OR_MORE),
        ('returns', expr, OPTIONAL),
    ]


class ClassDef(stmt):
    _fields = [
        ('name', identifier, NEEDED),
        ('bases', expr, ZERO_OR_MORE),
        ('keywords', keyword, ZERO_OR_MORE),
        ('starargs', expr, OPTIONAL),
        ('kwargs', expr, OPTIONAL),
        ('body', stmt, ZERO_OR_MORE),
        ('decorator_list', expr, ZERO_OR_MORE),
    ]


class Return(stmt):
    _fields = [
        ('value', expr, OPTIONAL),
    ]


class Delete(stmt):
    _fields = [
        ('targets', expr, ZERO_OR_MORE),
    ]


class Assign(stmt):
    _fields = [
        ('targets', expr, ZERO_OR_MORE),
        ('value', expr, NEEDED),
    ]


class AugAssign(stmt):
    _fields = [
        ('target', expr, NEEDED),
        ('op', operator, NEEDED),
        ('value', expr, NEEDED),
    ]


class For(stmt):
    _fields = [
        ('target', expr, NEEDED),
        ('iter', expr, NEEDED),
        ('body', stmt, ZERO_OR_MORE),
        ('orelse', stmt, ZERO_OR_MORE),
    ]


class While(stmt):
    _fields = [
        ('test', expr, NEEDED),
        ('body', stmt, ZERO_OR_MORE),
        ('orelse', stmt, ZERO_OR_MORE),
    ]


class If(stmt):
    _fields = [
        ('test', expr, NEEDED),
        ('body', stmt, ZERO_OR_MORE),
        ('orelse', stmt, ZERO_OR_MORE),
    ]


class With(stmt):
    _fields = [
        ('items', withitem, ZERO_OR_MORE),
        ('body', stmt, ZERO_OR_MORE),
    ]


class Raise(stmt):
    _fields = [
        ('exc', expr, OPTIONAL),
        ('cause', expr, OPTIONAL),
    ]


class Try(stmt):
    _fields = [
        ('body', stmt, ZERO_OR_MORE),
        ('handlers', ExceptHandler, ZERO_OR_MORE),
        ('orelse', stmt, ZERO_OR_MORE),
        ('finalbody', stmt, ZERO_OR_MORE),
    ]


class Assert(stmt):
    _fields = [
        ('test', expr, NEEDED),
        ('msg', expr, OPTIONAL),
    ]


class Import(stmt):
    _fields = [
        ('names', alias, ZERO_OR_MORE),
    ]


class ImportFrom(stmt):
    _fields = [
        ('module', identifier, OPTIONAL),
        ('names', alias, ZERO_OR_MORE),
        ('level', int, OPTIONAL),
    ]


class Future(stmt):
    _fields = [
        ('features', alias, ONE_OR_MORE),
    ]


class Global(stmt):
    _fields = [
        ('names', identifier, ZERO_OR_MORE),
    ]


class Nonlocal(stmt):
    _fields = [
        ('names', identifier, ZERO_OR_MORE),
    ]


class Expr(stmt):
    _fields = [
        ('value', expr, NEEDED),
    ]


class Pass(stmt):
    _fields = []


class Break(stmt):
    _fields = []


class Continue(stmt):
    _fields = []


class BoolOp(expr):
    _fields = [
        ('op', boolop, NEEDED),
        ('values', expr, ZERO_OR_MORE),
    ]


class BinOp(expr):
    _fields = [
        ('left', expr, NEEDED),
        ('op', operator, NEEDED),
        ('right', expr, NEEDED),
    ]


class UnaryOp(expr):
    _fields = [
        ('op', unaryop, NEEDED),
        ('operand', expr, NEEDED),
    ]


class Lambda(expr):
    _fields = [
        ('args', arguments, NEEDED),
        ('body', expr, NEEDED),
    ]


class IfExp(expr):
    _fields = [
        ('test', expr, NEEDED),
        ('body', expr, NEEDED),
        ('orelse', expr, NEEDED),
    ]


class Dict(expr):
    _fields = [
        ('keys', expr, ZERO_OR_MORE),
        ('values', expr, ZERO_OR_MORE),
    ]


class Set(expr):
    _fields = [
        ('elts', expr, ZERO_OR_MORE),
    ]


class ListComp(expr):
    _fields = [
        ('elt', expr, NEEDED),
        ('generators', comprehension, ZERO_OR_MORE),
    ]


class SetComp(expr):
    _fields = [
        ('elt', expr, NEEDED),
        ('generators', comprehension, ZERO_OR_MORE),
    ]


class DictComp(expr):
    _fields = [
        ('key', expr, NEEDED),
        ('value', expr, NEEDED),
        ('generators', comprehension, ZERO_OR_MORE),
    ]


class GeneratorExp(expr):
    _fields = [
        ('elt', expr, NEEDED),
        ('generators', comprehension, ZERO_OR_MORE),
    ]


class Yield(expr):
    _fields = [
        ('value', expr, OPTIONAL),
    ]


class YieldFrom(expr):
    _fields = [
        ('value', expr, NEEDED),
    ]


class Compare(expr):
    _fields = [
        ('left', expr, NEEDED),
        ('ops', cmpop, ZERO_OR_MORE),
        ('comparators', expr, ZERO_OR_MORE),
    ]


class Call(expr):
    _fields = [
        ('func', expr, NEEDED),
        ('args', expr, ZERO_OR_MORE),
        ('keywords', keyword, ZERO_OR_MORE),
        ('starargs', expr, OPTIONAL),
        ('kwargs', expr, OPTIONAL),
    ]


class Attribute(expr):
    _fields = [
        ('value', expr, NEEDED),
        ('attr', identifier, NEEDED),
        ('ctx', expr_context, NEEDED),
    ]


class Subscript(expr):
    _fields = [
        ('value', expr, NEEDED),
        ('slice', slice, NEEDED),
        ('ctx', expr_context, NEEDED),
    ]


class Starred(expr):
    _fields = [
        ('value', expr, NEEDED),
        ('ctx', expr_context, NEEDED),
    ]


class Name(expr):
    _fields = [
        ('id', identifier, NEEDED),
        ('ctx', expr_context, NEEDED),
    ]


class List(expr):
    _fields = [
        ('elts', expr, ZERO_OR_MORE),
        ('ctx', expr_context, NEEDED),
    ]


class Tuple(expr):
    _fields = [
        ('elts', expr, ZERO_OR_MORE),
        ('ctx', expr_context, NEEDED),
    ]


class Ellipsis(expr):
    _fields = []


class NameConstant(expr):
    _fields = [
        ('value', singleton, NEEDED),
    ]


class literal(expr):
    _fields = []


class Str(literal):
    _fields = [
        ('s', str, NEEDED),
    ]


class Bytes(literal):
    _fields = [
        ('s', bytes, NEEDED),
    ]


class num(literal):
    _fields = []


class Int(num):
    _fields = [
        ('n', int, NEEDED),
    ]


class Float(num):
    _fields = [
        ('n', float, NEEDED),
    ]


class Complex(num):
    _fields = [
        ('n', complex, NEEDED),
    ]


class Load(expr_context):
    _fields = []


class Store(expr_context):
    _fields = []


class Del(expr_context):
    _fields = []


class AugLoad(expr_context):
    _fields = []


class AugStore(expr_context):
    _fields = []


class Param(expr_context):
    _fields = []


class Slice(slice):
    _fields = [
        ('lower', expr, OPTIONAL),
        ('upper', expr, OPTIONAL),
        ('step', expr, OPTIONAL),
    ]


class ExtSlice(slice):
    _fields = [
        ('dims', slice, ZERO_OR_MORE),
    ]


class Index(slice):
    _fields = [
        ('value', expr, NEEDED),
    ]


class And(boolop):
    _fields = []


class Or(boolop):
    _fields = []


class Add(operator):
    _fields = []


class Sub(operator):
    _fields = []


class Mult(operator):
    _fields = []


class Div(operator):
    _fields = []


class Mod(operator):
    _fields = []


class Pow(operator):
    _fields = []


class LShift(operator):
    _fields = []


class RShift(operator):
    _fields = []


class BitOr(operator):
    _fields = []


class BitXor(operator):
    _fields = []


class BitAnd(operator):
    _fields = []


class FloorDiv(operator):
    _fields = []


class Invert(unaryop):
    _fields = []


class Not(unaryop):
    _fields = []


class UAdd(unaryop):
    _fields = []


class USub(unaryop):
    _fields = []


class Eq(cmpop):
    _fields = []


class NotEq(cmpop):
    _fields = []


class Lt(cmpop):
    _fields = []


class LtE(cmpop):
    _fields = []


class Gt(cmpop):
    _fields = []


class GtE(cmpop):
    _fields = []


class Is(cmpop):
    _fields = []


class IsNot(cmpop):
    _fields = []


class In(cmpop):
    _fields = []


class NotIn(cmpop):
    _fields = []
