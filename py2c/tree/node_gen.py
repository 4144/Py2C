"""Node file generator

This file generates the Python files from the DSL we made, for the nodes that
we use during the translation. This way of describing nodes, allows DRY-ness of
source code.
"""

#------------------------------------------------------------------------------
# Py2C - A Python to C++ compiler
# Copyright (C) 2014 Pradyun S. Gedam
#------------------------------------------------------------------------------

import os
import re
import collections
from textwrap import dedent

import ply.lex
import ply.yacc

PREFIX = dedent("""
    #------------------------------------------------------------------------------
    # Py2C - A Python to C++ compiler
    # Copyright (C) 2014 Pradyun S. Gedam
    #------------------------------------------------------------------------------

    # This file is auto-generated by py2c.tree.node_gen .
    #------------------------------------------------------------------------------
    # ANY CHANGES YOU MAKE IN THIS FILE DIRECTLY WILL BE LOST.
    #------------------------------------------------------------------------------
    # Instead of modifying this file, modify the relevant "*.tree" file
    # in py2c/tree directory of the source distribution.

    from . import (
        Node,
        identifier, singleton,
        NEEDED, OPTIONAL, ONE_OR_MORE, ZERO_OR_MORE
    )
""").strip()


#------------------------------------------------------------------------------
# Exceptions
#------------------------------------------------------------------------------
class ParserError(Exception):
    """Errors raised by the Parser while Parsing
    """


#------------------------------------------------------------------------------
# Helpers
#------------------------------------------------------------------------------
def remove_comments(text):
    """Removes all text after a '#' in all lines of the text
    """
    return re.sub(r"(?m)\#.*($|\n)", "", text)


def _prettify_list(li):
    """
    """
    if li == []:
        return "[]"
    else:
        lines = ["["]
        for name, type_, modifier in li:
            lines.append(
                " "*8 + "({!r}, {}, {}),".format(name, type_, modifier)
            )
        lines.append(" "*4 + "]")

        return "\n".join(lines)


Node = collections.namedtuple("Node", "name parent attrs")


#------------------------------------------------------------------------------
# Parsing of AST nodes declaration
#------------------------------------------------------------------------------
class Parser(object):
    """Parses the definitions in the definition files
    """

    def __init__(self):
        super(Parser, self).__init__()
        self.tokens = ("INHERIT", "NAME",)
        self.literals = "()[]:*?+,"

        # Tokens for lexer
        self.t_INHERIT = r"inherit"
        self.t_NAME = r"\w+"
        self.t_ignore = " \t"

        self._lexer = ply.lex.lex(module=self)
        self._parser = ply.yacc.yacc(module=self, start="start")

        self.seen_node_names = set()

    def t_newline(self, t):
        r"\n"
        t.lexer.lineno += 1

    def t_error(self, t):
        raise ParserError("Unable to generate tokens from: " + repr(t.value))

    #--------------------------------------------------------------------------
    # API
    #--------------------------------------------------------------------------
    def parse(self, text):
        """Parses the definition text into a data representation of it.
        """
        text = remove_comments(text)
        return self._parser.parse(text, lexer=self._lexer)

    #--------------------------------------------------------------------------
    # Parsing
    #--------------------------------------------------------------------------
    def p_error(self, t):
        raise ParserError("Unexpected token: " + str(t))

    def p_empty(self, p):
        "empty : "

    def p_start(self, p):
        "start : zero_or_more_declaration"
        p[0] = p[1]

    def p_zero_or_more_declaration(self, p):
        """zero_or_more_declaration : zero_or_more_declaration declaration
                                    | empty
        """
        if len(p) == 2:
            p[0] = ()
        else:
            p[0] = p[1] + (p[2],)

    def p_declaration(self, p):
        "declaration : NAME parent_class_opt ':' attributes"
        name, parent, attrs = (p[1], p[2], p[4])
        if name in self.seen_node_names:
            raise ParserError(
                "Multiple declarations of name {!r}".format(name)
            )
        self.seen_node_names.add(name)

        if attrs != 'inherit':
            # Check for duplicate fields
            seen_fields = []
            duplicated_fields = []
            for field_name, _, _ in attrs:
                if field_name in seen_fields:
                    duplicated_fields.append(field_name)
                else:
                    seen_fields.append(field_name)

            if duplicated_fields:
                msg = "Multiple declarations in {!r} of attribute{} {!r}".format(
                    name,
                    "s" if len(duplicated_fields) > 1 else "",
                    ", ".join(duplicated_fields)
                )
                raise ParserError(msg)
        elif parent is None:
            msg = "Inheriting nodes needs parents to inherit from them."
            raise ParserError(msg)

        p[0] = Node(name, parent, attrs)

    def p_parent_class_opt(self, p):
        """parent_class_opt : '(' NAME ')'
                            | empty
        """
        if len(p) > 2:
            p[0] = p[2]
        else:
            p[0] = None

    def p_attributes(self, p):
        """attributes : '[' attr_list ']'
                      | INHERIT
        """
        if len(p) == 2:
            p[0] = p[1]
        else:
            p[0] = p[2]

    def p_attr_list(self, p):
        """attr_list : attr more_attrs_maybe ','
                     | attr more_attrs_maybe
                     | empty
        """
        if len(p) > 2:
            p[0] = [p[1]] + p[2]
        else:
            p[0] = []

    def p_more_attrs_maybe(self, p):
        """more_attrs_maybe : more_attrs_maybe ',' attr
                            | empty
        """
        if len(p) > 2:
            p[0] = p[1] + [p[3]]
        else:
            p[0] = []

    def p_attr(self, p):
        "attr : NAME modifier NAME"
        p[0] = (p[3], p[1], p[2])

    def p_modifier(self, p):
        """modifier : empty
                    | '?'
                    | '+'
                    | '*'
        """
        if p[1] == "+":
            p[0] = "ONE_OR_MORE"
        elif p[1] == "*":
            p[0] = "ZERO_OR_MORE"
        elif p[1] == "?":
            p[0] = "OPTIONAL"
        else:
            p[0] = "NEEDED"


#------------------------------------------------------------------------------
# Generation of sources for AST nodes class
#------------------------------------------------------------------------------
class SourceGenerator(object):
    """Generates the code from the Parser's parsed data
    """

    def __init__(self):
        super(SourceGenerator, self).__init__()

    def generate_sources(self, data):
        """Generates source code from the data generated by :py:class:`Parser`
        """
        classes = []
        for node in data:
            classes.append(self._translate_node(node))
        # Join classes and ensure newline at EOF
        return "\n\n\n".join(classes) + "\n"

    def _translate_node(self, node):
        name = node.name
        if node.attrs == "inherit":
            field_text = node.parent + "._fields"
        else:
            field_text = _prettify_list(node.attrs)
        # node.parent is None or a string...
        parent = node.parent or "object"
        return dedent("""
            class {0}({1}):
                _fields = {2}
        """).strip().format(name, parent, field_text)


# API
def generate(source_dir, output_dir=None, update=False):  # coverage: not missing
    """Generate sources for the Nodes definition files in ``source_dir``
    """
    if output_dir is None:
        output_dir = source_dir

    files_to_convert = [
        fname for fname in os.listdir(os.path.realpath(source_dir))
        if fname.endswith(".tree")
    ]

    # Writing the node-declaration files
    parser = Parser()
    src_gen = SourceGenerator()

    for fname in files_to_convert:
        infile_name = os.path.join(source_dir, fname)
        outfile_name = os.path.join(output_dir, fname[:-5] + ".py")
        if os.path.exists(outfile_name) and not update:
            continue

        with open(infile_name, "rt") as infile:
            text = infile.read()

        sources = src_gen.generate_sources(parser.parse(text))

        print("---- Generated {}".format(outfile_name))
        with open(outfile_name, "w+t") as outfile:
            outfile.write(PREFIX)
            outfile.write("\n\n\n")
            outfile.write(sources)

if __name__ == '__main__':
    generate("py2c/tree", "py2c/tree", True)
